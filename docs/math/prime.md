我们说，如果存在一个整数 $k$，使得 $a = kd$，则称 d 整除 a，记做 $d | a$，称 a 是 d 的倍数，如果 $d > 0$，称 d 是 a 的约数。特别地，任何整数都整除 0。

显然数 a 可以被 1 和 a，如果除此之外 a 没有其他的约数，则称 a 是素数。任何一个大于 1 的整数如果不是素数，就称为是合数。一个合数是除了 1 和它自身以外还有别的约数的数。1 既不是合数也不是约数。

## 素数判定

我们自然地会想到，如何用计算机来判断一个数是不是素数呢？

### 暴力做法

自然可以枚举从小到大的每个数看是否能整除

```c++
bool isPrime(a) {
  for (int i = 2; i < a; ++i) if (a % i == 0) return 0;
  return 1;
}
```

这样做是十分稳妥了，但是真的有必要每个数都去判断吗？

很容易发现这样一个事实：如果 x 是 a 的约数，那么 $a / x$ 也是 a 的约数。

这个结论告诉我们，对于每一对 $(x, a / x)$，只需要检验其中的一个就好了。为了方便起见，我们之考察每一对里面小的那个数。不难发现，所有这些较小数就是 $[1 .. \sqrt(a)]$ 这个区间里的数。

由于 1 肯定是约数，所以不检验它。

```c++
bool isPrime(a) {
  for (int i = 2; i * i <= a; ++i) if (a % i) return 0;
  return 1;
}
```

### Miller-Rabbin

Miller-Rabbin 算法是进阶的素数判定方法，具有比暴力做法更好的时间复杂度。但是代码复杂度较高，在比赛中使用较少。

它的基本思想是不断地选取不超过 $n-1$ 的基 $b$，并检验是否每次都有 $b^{n-1} \\bmod n = 1$

```c++
bool millerRabbin(int n) {
  for (int i = 1; i <= s; ++i) {
    int a = rand() % (n - 2) + 2;
    if (quickPow(a, n - 1, n) != 1) return 0;
  }
  return 1;
}
```
