排序算法多种多样，性质也大多不同。

## 稳定性

稳定性是指相等的元素经过排序之后相对顺序是否发生了改变。

我们常用的归并排序是稳定排序，而快速排序不是稳定排序。

## 时间复杂度

时间复杂度用来衡量一个算法的运行时间和输入规模的关系，类似的有空间复杂度，用来描述算法的空间消耗的规模。

简单计算复杂度的方法一般是统计“简单操作”的执行次数，有时候也可以直接数循环的层数来近似估计。

时间复杂度分为最坏时间复杂度、平均时间复杂度、最好时间复杂度等等。OI 竞赛中要考虑的一般是最坏时间复杂度，因为它代表的是算法运行水平的下界，在评测中不会出现更差的结果了。

基于比较的排序算法的时间复杂度下限是 $O(n\log n)$ 的。

当然也有不是 $O(n\log n)$ 的，桶排序的时间复杂度是 $O(n)$，但是它是在「用空间换时间」，它的空间复杂度是 $O(所排序的最大数)$

## 归并排序

## 快速排序

C函数模板库实现了快速排序，即`stdlib.h`当中的`qsort`。但在OI相关比赛当中，更为常见的库排序函数是C++ `algorithm`库中的`std::sort`函数。C++标准并未严格要求此函数的实现算法，具体实现取决于编译器，但他的时间复杂度是$O(N\log N)$的。可以查阅 [std::sort()](http://www.cplusplus.com/reference/list/list/sort/)

快速用法：
```c++
// a[0] .. a[n - 1] 是放了元素的
std::sort(a, a + n);
// 这句代码直接修改 a 数组里的元素顺序，使得现在它是从小到大排列的
```
