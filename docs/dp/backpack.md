在学习本章前请确认你已经学习了[动态规划部分简介](/dp/)

## 背包问题

背包问题是一个[NP 完全问题](https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8)，问题可以描述为，给定一些物品，每种物品有它的数量，价格和重量，求在重量限度内能获得多少价值。

常见的背包问题有 01 背包、多重背包和完全背包。

对于这个问题，常常会有一种错误的贪心做法，即先求出各个物品的 “性价比”，再按这个值的大小从大到小选择，然而这是错的。反例：

三件物品，前两件的重量为 5，价值为 5，第三件的重量为 6，价值为 7，背包容量为 10，按照贪心做法，会选取第三件，之后就没法选了，收益为 7，然而正确做法应该选取前两个，收益为 10.

## 0-1 背包

??? note 例题 [\[USACO07DEC\] 手链 Charm Bracelet](https://www.luogu.org/problemnew/show/P2871)"
    本题题意可概括为——N 物体，放入容量为 M 的背包，要求使总价值最大。由于每个物体只有 2 种情况——取与不取（即取一个和取两个），正如二进制中的 0 和 1——这类问题便被称为 “0-1 背包问题”。

例题中已知条件有第 i 个物体的体积 v[i]和价值 w[i], 背包总容量

显而易见的是，可以计算总价值的，只有已经放入背包的物体，因此该题中对 "是否为最大值" 的判断是建立在 "已经放入背包之中" 的基础之上的

已知对于一个容量为 v1，可以放置第 1 到第 i 件物体的背包，其最大总价值很明显等于容量为 v1 的背包，放有第 1 到第 (i-1) 件物体时的最大值（第 i 件物体不取时）或者是容量为 v1-v[i]的背包，放有第 1 到第 (i-1) 件物体时的最大值 + w[i](第i件物体取时)

由此可以得出状态转移方程

-   dp[v1][i]=max(dp[v1][i-1],dp[v1-v\[i\]][i-1]+w[i])

因为转移方程只涉及到 dp[x][i]和 dp[x][i-1]。所以可以用滚动数组优化掉一维。即设 f[i]为取 i 的最大收益，显然每次 f[i]是所有 f\[i-v[j]] 的最大值加上 w[j]

有了这样的思路，就可以顺利地写出代码了

```cpp
for (int i = 1; i <= v1; i++)
  for (int l = 0; l <= v1 - i; l++) dp[l + i] = max(dp[l] + w[i], dp[l + i]);
```

按照正确的思路，写出了这样的核心代码，然后就可以提交……

错！

让我们再回头看一下代码，i 表示当前判断的是第 i 个物体，l 则穷举体积，可是注意一个地方——l 是从 0 到 v1-v[i]

这意味着什么呢？举个栗子，可能在体积为 (l) 处取物体 i 新的 dp 值存到体积为 (l+v[i]) 处，而在体积为 (l+v[i]) 处，物体 i 再次被取

所以，当以 0~v1-v[i]的顺序穷举时，物体实际上可能被加入多遍，这显然与题意不符

因此为了避免多取，穷举顺序应为 v1-v[i]~0

因此实际核心代码为

```cpp
for (int i = 1; i <= v1; i++)
  for (int l = v1 - i; l >= 0; l--) dp[l + i] = max(dp[l] + w[i], dp[l + i]);
```

例题代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 13010;
int n, v, c[maxn], w[maxn], most[maxn];
int main() {
  cin >> n >> v;
  for (int i = 1; i <= n; i++) {
    cin >> c[i] >> w[i];
  }
  for (int i = 1; i <= n; i++)
    for (int l = v; l >= c[i]; l--) {
      if (most[l - c[i]] + w[i] > most[l]) most[l] = most[l - c[i]] + w[i];
    }
  cout << most[v];
  return 0;
}
```

Ps. 事实上，由小到大穷举是另一种背包问题的解法，稍后会提到

## 完全背包

完全背包问题，也是每种物品有一个价值和重量，但每种物品都有**无限个**

怎么做呢，观察 01 背包的核心代码:

```cpp
for (int i = 1; i <= n; i++)
  for (int l = v; l >= c[i]; l--) {
    if (f[l - c[i]] + w[i] > f[l]) f[l] = f[l - c[i]] + w[i];
  }
```

注意第二层的 for 循环，从 c[i]开始遍历到 v，为什么不行呢？

因为我们使用的是滚动数组，从小到大遍历，会覆盖掉前一维，导致一个物品被选多次的情况

而一个物品被选多次，恰好就是完全背包问题的一个解决方法。

所以，从小到大遍历，就是完全背包问题的解决方式，核心代码为:

```cpp
for (int i = 1; i <= n; i++)
  for (int l = c[i]; l >= v; l--) {
    if (f[l - c[i]] + w[i] > f[l]) f[l] = f[l - c[i]] + w[i];
  }
```

## 多重背包

多重背包问题，也是每种物品有一个价值和重量，但每种物品都有 num[i]个。

怎么解决呢？一种显然的做法就是把一种物品拆成多个物品，变成了 01 背包问题解决。这样最坏复杂度变成了 O(nm\*num) 退化掉了一维。

有一种比较普遍的优化方法就是**二进制拆分**，也是把一种物品拆成多个物品，但是每个物品的重量和价值也随之改变

如有 7 个重量为 w，价值为 v 的物品，那么我们把它拆成三个物品：

第一个：重量为 4\*w，价值为 4\*v；第二个重量为 2\*w，价值为 2\*v; 第三个: 重量为 w，价值为 v

然后使用 01 背包解决，为什么这样可行呢？因为无论要取多少物品，都可以通过取这三个物品中的某几个方法解决

令 k=log(num)（向下取整）

我们把它拆成了由 k+1 个物品，则每个物品的系是 1,2,4,...,2^(k-1),num-2^k+1。

可以证明，无论要取多少物品，都可以由这些物品的组合解决。

那么这样的复杂度为 O(nm\*log(num)），已经大大优化，可以通过大部分多重背包题目，然而，是否存在更优的算法呢？

事实上，多重背包存在着 O(nm) 的算法：

利用剩余系（当 x 和 y 模 p 为同一个值，则 x 和 y 在模 p 意义下的同一个剩余系）。状态改为 f[i][j]表示前 i 种物品，剩余体积为 j，考虑当前遍历到第 i 个物品，f[i][j]的前导状态，都属于模 w[i]的同一个剩余系，而不同剩余系中的状态不互相影响，于是我们将当前第 i 个物品按剩余类划分，每次只更新一个剩余类。

换一种解释的方法，设 num[i]=2,v[i]=v,w[i]=w, 总容量 > 9\*v.

暴力拆成 01 背包的转移方程为：F[i][j]=max(F[i-1]j–k\*v[i]]+k\*w[i])(0&lt;=k&lt;=m[i])

根据上面的方程，f[i][j]的最大值由一下几种情况得来：

j=6\*v 时：f[i][j]=max(f([i-1][6\*v]),f(5\*v)+w,f(4\*v)+2\*w)

j=5\*v 时：f[i][j]=max(f([i-1][5\*v]),f(4\*v)+w,f(3\*v)+2\*w)

j=4\*v 时：f[i][j]=max(f([i-1][4\*v]),f(3\*v)+w,f(2\*v)+2\*w)

将 j=6\*v 时，每项减去 6\*w，j=5\*v 时，每项减去 5\*w，j=4\*v 时，每项减去 4\*w:

j=6\*v：f[i][j]=max(f([i-1][6\*v])-6\*w,f(5\*v)-5\*w,f(4\*v)-4\*w)

j=5\*v：f[i][j]=max(f([i-1][5\*v])-5\*w,f(4\*v)-4\*w,f(3\*v)-3\*w)

j=4\*v：f[i][j]=max(f([i-1][4\*v])-4\*w,f(3\*v)-3\*w,f(2\*v)-2\*w)

我们发现，这九个项中有很多重复，这些就是求值时可以避免重复计算的。

根据这个重复，我们尝试修改原来的方程：

设 a,b 满足 j=a\*v[i]+b，且 j%v[i]=b. 并将 k 改为 a-k，代入原来的公式：

f[i][j]=max(f[i-1][b+k\*d]-k\*w[i])+a\*w[i]

即 f[i][j]就是 j 的前面 num[i]+1 个数对应的 f[i-1][b+k\*d]-k\*w[i]的最大值，加上 a\*w[i]，我们把 f[i][j]前面所有的 f[i-1][b+k\*d]–k\*w[i]放入到一个队列，每次转移就求一次这个队列的最大值。而这个经典问题可以用单调队列解决。

这样的时间复杂度就是 O(nm) 的了。
